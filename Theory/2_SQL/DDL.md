# DDL

## Оператор CREATE

### Создание таблицы

#### PostgreSQL

##### Types

https://www.postgresql.org/docs/12/datatype.html

**Numeric:**
https://www.postgresql.org/docs/12/datatype-numeric.html

Используйте тип serial для первичного ключа!
В PostgreSQL serial - автоинкрементированный тип, т.е. он будет увеличиваться на 1 с каждой добавленной записью. Такое поведение можно сделать при помощи Integer, но тогда придётся в ручную создать последовательность. Serial не совсем тип данных, это скорее короткая запись. Поэтому в таблицах, которые ссылаются на таблицу с serial должен использоваться уже тип integer (bigserial -> bigInt соответственно)!!!

https://www.postgresql.org/docs/12/datatype-numeric.html#DATATYPE-SERIAL

smallint
integer
bigint
decimal
point
numeric
point
real
double
smallserial
serial
bigserial

**Date/Time:**
timestamp without time zone
timestamp with time zone
date
time without time zone
time with time zone
interval

**character:**
varchar(n) - текст с n - максимальным значением символов
text - текст без ограничений длины

##### Create синтаксис

```sql
CREATE TABLE supplier (
	id serial PRIMARY KEY,
	name varchar(255),
	city varchar(100),-- DEFAULT 'Москва',
	street varchar(100),
	house varchar(20),
	phone varchar(20),
	email varchar(100) NOT NULL UNIQUE
)
```

Или

```sql
CREATE TABLE supplier (
	id serial,
	name varchar(255),
	city varchar(100),
	street varchar(100),
	house varchar(20),
	phone varchar(20),
	email varchar(100) NOT NULL UNIQUE,
	PRIMARY KEY(id)
)
```

Или

```sql
CREATE TABLE supplier (
	id serial,
	name varchar(255),
	city varchar(100),
	street varchar(100),
	house varchar(20),
	phone varchar(20),
	email varchar(100) NOT NULL UNIQUE,
	--rating integer(1) CHECK (1 <= rating <= 5),
	CONSTRAINT supplier_id_pk PRIMARY KEY (id)
)
```

### Foreign Key

Допустим, мы хотим добавить таблицу supplier_info, в которой есть ссылка на таблицу supplier. Это можно сделать следующими способами:

1. На той же строчке, что и атрибут, без упоминания атрибута с которым связываем. Удобно, когда в supplier не составной первичный ключ. (Обратите внимание, что supplier_id - integer, а не serial! Это важно)

```sql
CREATE TABLE supplier_info (
	id serial PRIMARY KEY,
	supplier_id integer REFERENCES supplier,
	info varchar(5000)
)
```

2. На той же строке, но с указанием атрибута, с которым связываем

```sql
CREATE TABLE supplier_info (
	id serial PRIMARY KEY,
	supplier_id integer REFERENCES supplier (id),
	info varchar(5000)
)
```

3. Внутри Create Table, но уже после указания атрибутов. Этот вариант даёт возможность самостоятельно назвать внешний ключ

```sql
CREATE TABLE supplier_info (
	id serial PRIMARY KEY,
	supplier_id integer,
	info varchar(5000),
	CONSTRAINT supplier_info_supplier_id_fk FOREIGN KEY (supplier_id)
		REFERENCES supplier (id)
)
```

---

Оператор CREATE служит для создания любого типа объектов, из которых состоит база данных, в том числе таблиц.

Синтаксис команды создания таблицы:

```sql
CREATE  TABLE  имя_таблицы(
поле1 тип1 [ограничения],
[поле2 тип2 [ограничения],
…]);
```

Возможные ограничения в таблицах:

- NOT NULL – значение атрибута должно быть определено (опция NOT NULL);
- UNIQUE – значения атрибутов являются уникальными (уникальный ключ);
- PRIMARY KEY – атрибут является первичным ключом (первичный ключ);
- CHECK – определяет условие, которому должны удовлетворять значения атрибута (домен);
- DEFAULT – присвоение значений «по умолчанию» для атрибутов.

Используя приведенный выше синтаксис, вместе с созданием таблицы можно вместе с атрибутами таблицы сразу же задать и ограничения декларативной и ссылочной целостности, но только в том случае, если они касаются только одного конкретного атрибута. Если же первичный, уникальный или вторичный ключ должны быть составными, для их создания нужно применять команду ALTER TABLE.

Например, для создания таблицы Students достаточно выполнить следующую команду:

```sql
CREATE TABLE STUDENTS (
    IDACH NUMBER(5,0),
	NAME VARCHAR(150),
	SURNAME VARCHAR(150),
	N_GROUP NUMBER(4,0),
	ADDRESS VARCHAR(200),
	date_birth DATE,
	AVERAGE_SCORE NUMBER(3,2),
	CONSTRAINT STUDENTS_PK PRIMARY KEY (IDACH)
  USING INDEX  ENABLE
   )
```

Обратите внимание. Если при создании вы используете ", например "student" (именно маленькими), то название таблицы/атрибута станет чувствительным к регистру. Плюсы - можно написать зарезервированное слово, например "count". Минусы - придётся в любом запросе ещё использовать кавычки, что не особо удобно.

#### Создание копии таблицы

Иногда необходимо создать таблицу в точности или частично по структуре и содержанию копирующую какую-либо из существующих таблиц. В этом случае используется следующий синтаксис:

```sql
CREATE TABLE имя_таблицы AS оператор SELECT
```

Например, для того чтобы создать копию таблицы Students можно выполнить следующую команду:

```sql
CREATE TABLE Students_Copy AS SELECT * FROM STUDENTS;
```

## Оператор ALTER

Оператор ALTER служит для изменения структуры любых объектов, из которых состоит база данных. В зависимости от типа объекта, изменяются и параметры команды ALTER.

### Добавление атрибута таблицы

Для добавления атрибута к таблице применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблиц_ ADD поле тип [ограничения];
```

Например, для добавления к таблице Students поля n_group можно выполнить следующую команду:

```sql
ALTER TABLE student ADD n_group NUMBER(4);
```

### Удаление атрибута таблицы

Для удаления атрибута таблицы применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы DROP COLUMN поле;
```

### Изменение типа атрибута, размера типа и наличия ограничения NOT NULL

Для изменения типа данных атрибута, размера типа данных или наличия опции NOT NULL используется следующие синтаксис:

```sql
ALTER TABLE  имя_таблицы MODIFY  поле  тип [ограничения];
```

При изменении типов данных и размеров типов данных атрибутов следует соблюдать осторожность. Дело в том, что при «сужении» области допустимых значений, который может принимать атрибут, могут быть утеряны («обрезаны») данные, выходящие за пределы новой области допустимых значений.

### Создание первичного ключа

Для создания первичного ключа используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY  KEY(список_полей);
```

Например, для создания первичного ключа таблицы Students можно выполнить следующую команду:

```sql
ALTER TABLE Students ADD CONSTRAINT Students_PK PRIMARY  KEY(id);
```

Если создаваемый первичный ключ является составным, то есть состоит из нескольких атрибутов, атрибуты перечисляются через запятую.

### Создание уникального ключа

Для создания уникального ключа используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения UNIQUE(_список_полей_);
```

Например, для создания уникального ключа в таблице Students, гарантирующего уникальность значений в атрибуте Comments, можно выполнить следующую команду:

```sql
ALTER TABLE Students ADD CONSTRAINT Students_Comm_uk UNIQUE (Comment);
```

### Создание домена

Для создания домена используется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения CHECK(_условное_выражение_);
```

При наличии домена в таблице, каждый раз при изменении или добавлении значений в атрибуты, затрагиваемые условным выражением, СУБД будет проверять новое значение атрибутов на удовлетворение указанному выражению. Новое значение будет присвоено атрибуту только в том случае, если значение удовлетворяет указанному условию. При составлении условных выражений можно использовать логические операции >, <, >=, <=, <>, =, функции IN (проверка вхождения в множество), BETWEEN (проверка вхождения в диапазон), LIKE (проверка на удовлетворению шаблону). Кроме того, несколько условных выражений можно комбинировать при помощи логических операторов AND, OR и NOT.

```sql
ALTER TABLE Students ADD CONSTRAINT Students_Ngr_check CHECK(n_group >= 0);
```

### Создание внешнего ключа

Для добавления внешнего ключа используется следующий синтаксис:

```sql
ALTER  TABLE  имя_подчиненной_таблицы
ADD  CONSTRAINT  имя_ограничения
FOREIGN  KEY(список_полей_подчиненной_таблицы)
REFERENCES  имя_главной_таблицы(список_полей_главной_таблицы)
[ON UPDATE CASCADE | SET NULL | SET DEFAULT | NO ACTION]
[ON UPDATE CASCADE | SET NULL | SET DEFAULT | NO ACTION];
```

Параметры _ON_ _UPDATE_ и _ON_ _DELETE_ указываются при необходимости осуществлять каскадные действия при, соответственно, изменении или удалении значений атрибутов первичного ключа главной таблицы. При попытке изменения значения атрибута, входящего в состав первичного ключа, или удаления строки, на которую ссылаются строки из подчиненных таблиц, СУБД принимает решение либо о выполнении одного из каскадных действий, либо о запрещении SQL-оператора, изменяющего или удаляющего строку в главной таблице.

Если параметры ON UPDATE или ON DELETE равны NO ACTION или они не указаны совсем, СУБД запретит выполнение SQL-оператора, нарушающего ссылочную целостность.

Если после параметров ON UPDATE или ON DELETE стоит значение CASCADE, то произойдет каскадное изменение или удаление строк в подчиненных таблицах. Иными словами, при удалении строки из главной таблицы, будут удалены все строки в подчиненных таблицах, которые ссылались на удаляемую строку. При изменении значения первичного ключа главной таблицы и наличии параметра ON UPDATE со значением CASCADE все значения внешних ключей, ссылающихся на изменяемый атрибут, также изменят свое значение.

Использовать значение CASCADE параметров ON UPDATE и ON DELETE следует с особой осторожностью, поскольку одна ошибочная команда, например, удаления строки в одной из таблиц может повлечь за собой необратимые последствия, которые могут привести к полной неработоспособности приложений базы данных. Если все-таки необходимо выполнять каскадное изменение или удаление данных в подчиненных таблицах, рекомендуется, по возможности, реализовывать это посредством хранимых процедур.

Указание значения SET NULL для параметров ON UPDATE или ON DELETE приведет к тому, что значения атрибутов внешних ключей, ссылающихся на изменяемое значение первичного ключа, установится в NULL.

Указание значения SET DEFAULT для параметров ON UPDATE или ON DELETE приведет к тому, что значения атрибутов внешних ключей, ссылающихся на изменяемое значение первичного ключа, примут значение по умолчанию, заданное при создании таблицы.

Пример создания внешнего ключа, связывающего таблицы Students_Hobby и Students можно выполнить следующую команду:

```sql
ALTER TABLE Students_Hobby ADD CONSTRAINT Students_Hobby_fk FOREIGN KEY(id) REFERENCES Students(id);
```

### Удаление ограничений целостности

Для удаления ограничения целостности (первичного ключа, уникального ключа или внешнего ключа) применяется следующий синтаксис:

```sql
ALTER TABLE имя_таблицы DROP CONSTRAINT имя_ограничения;
```

Например, для удаления внешнего ключа связывающего таблицы Students_Hobby и Students можно выполнить следующую команду:

```sql
ALTER TABLE Students_Hobby DROP CONSTRAINT Students_Hobby_fk;
```

## Оператор DROP

Оператор DROP служит для удаления объектов из базы данных. Синтаксис удаления любого типа объекта из базы данных, в том числе таблицы, выглядит следующим образом:

DROP _тип объекта имя объекта_;

В данном случае таблица успешно удалится только в том случае, если на нее не ссылаются внешний ключи других таблиц. В том случае, если внешние ключи существуют, но удалить таблицу все-таки необходимо, можно, либо сначала удалить все внешние ключи, ссылающиеся на удаляемую таблицу, после чего удалить таблицу, либо используя параметр CASCADE CONSTRAINTS:

```sql
DROP TABLE Имя_Таблицы CASCADE CONSTRAINTS;
```

В последнем случае, если внешние ключи, ссылающиеся на удаляемую таблицу, существуют, они будут удалены без изменений в полях внешних ключей подчиненных таблиц, даже если при создании внешних ключей были указаны параметры, задающие каскадные действия.
